###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         25/Nov/2017  22:13:50 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom\Proj #
#                          ects\zstack\Samples\GreenClassroom_NetWork         #
#                          2.1\Source\hal_key.c                               #
#    Command line       =  -f "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom\ #
#                          Projects\zstack\Samples\GreenClassroom_NetWork     #
#                          2.1\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg" #
#                           (-DCPU32MHZ -DROOT=__near_func                    #
#                          -DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6         #
#                          -DMAC_CFG_RX_MAX=3) -f "D:\FileInstall\ZStack-CC25 #
#                          30-2.5.1a_GreenRoom\Projects\zstack\Samples\GreenC #
#                          lassroom_NetWork 2.1\CC2530DB\..\..\..\Tools\CC253 #
#                          0DB\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0         #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "D:\FileInstall\ZStack-CC25 #
#                          30-2.5.1a_GreenRoom\Projects\zstack\Samples\GreenC #
#                          lassroom_NetWork 2.1\Source\hal_key.c" -D          #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D            #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -D xPOWER_SAVING -lC "D:\FileInstall\ZStack-CC2530 #
#                          -2.5.1a_GreenRoom\Projects\zstack\Samples\GreenCla #
#                          ssroom_NetWork 2.1\CC2530DB\EndDeviceEB\List\"     #
#                          -lA "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom #
#                          \Projects\zstack\Samples\GreenClassroom_NetWork    #
#                          2.1\CC2530DB\EndDeviceEB\List\" --diag_suppress    #
#                          Pe001,Pa010 -o "D:\FileInstall\ZStack-CC2530-2.5.1 #
#                          a_GreenRoom\Projects\zstack\Samples\GreenClassroom #
#                          _NetWork 2.1\CC2530DB\EndDeviceEB\Obj\" -e         #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom\ #
#                          Projects\zstack\Samples\GreenClassroom_NetWork     #
#                          2.1\CC2530DB\" -I "D:\FileInstall\ZStack-CC2530-2. #
#                          5.1a_GreenRoom\Projects\zstack\Samples\GreenClassr #
#                          oom_NetWork 2.1\CC2530DB\..\Source\" -I            #
#                          "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom\Pro #
#                          jects\zstack\Samples\GreenClassroom_NetWork        #
#                          2.1\CC2530DB\..\..\..\ZMain\TI2530DB\" -I          #
#                          "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom\Pro #
#                          jects\zstack\Samples\GreenClassroom_NetWork        #
#                          2.1\CC2530DB\..\..\..\..\..\Components\hal\include #
#                          \" -I "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRo #
#                          om\Projects\zstack\Samples\GreenClassroom_NetWork  #
#                          2.1\CC2530DB\..\..\..\..\..\Components\hal\target\ #
#                          CC2530EB\" -I "D:\FileInstall\ZStack-CC2530-2.5.1a #
#                          _GreenRoom\Projects\zstack\Samples\GreenClassroom_ #
#                          NetWork 2.1\CC2530DB\..\..\..\..\..\Components\mac #
#                          \include\" -I "D:\FileInstall\ZStack-CC2530-2.5.1a #
#                          _GreenRoom\Projects\zstack\Samples\GreenClassroom_ #
#                          NetWork 2.1\CC2530DB\..\..\..\..\..\Components\mac #
#                          \high_level\" -I "D:\FileInstall\ZStack-CC2530-2.5 #
#                          .1a_GreenRoom\Projects\zstack\Samples\GreenClassro #
#                          om_NetWork 2.1\CC2530DB\..\..\..\..\..\Components\ #
#                          mac\low_level\srf04\" -I                           #
#                          "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom\Pro #
#                          jects\zstack\Samples\GreenClassroom_NetWork        #
#                          2.1\CC2530DB\..\..\..\..\..\Components\mac\low_lev #
#                          el\srf04\single_chip\" -I                          #
#                          "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom\Pro #
#                          jects\zstack\Samples\GreenClassroom_NetWork        #
#                          2.1\CC2530DB\..\..\..\..\..\Components\mt\" -I     #
#                          "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom\Pro #
#                          jects\zstack\Samples\GreenClassroom_NetWork        #
#                          2.1\CC2530DB\..\..\..\..\..\Components\osal\includ #
#                          e\" -I "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenR #
#                          oom\Projects\zstack\Samples\GreenClassroom_NetWork #
#                           2.1\CC2530DB\..\..\..\..\..\Components\services\s #
#                          addr\" -I "D:\FileInstall\ZStack-CC2530-2.5.1a_Gre #
#                          enRoom\Projects\zstack\Samples\GreenClassroom_NetW #
#                          ork 2.1\CC2530DB\..\..\..\..\..\Components\service #
#                          s\sdata\" -I "D:\FileInstall\ZStack-CC2530-2.5.1a_ #
#                          GreenRoom\Projects\zstack\Samples\GreenClassroom_N #
#                          etWork 2.1\CC2530DB\..\..\..\..\..\Components\stac #
#                          k\af\" -I "D:\FileInstall\ZStack-CC2530-2.5.1a_Gre #
#                          enRoom\Projects\zstack\Samples\GreenClassroom_NetW #
#                          ork 2.1\CC2530DB\..\..\..\..\..\Components\stack\n #
#                          wk\" -I "D:\FileInstall\ZStack-CC2530-2.5.1a_Green #
#                          Room\Projects\zstack\Samples\GreenClassroom_NetWor #
#                          k 2.1\CC2530DB\..\..\..\..\..\Components\stack\sap #
#                          i\" -I "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenR #
#                          oom\Projects\zstack\Samples\GreenClassroom_NetWork #
#                           2.1\CC2530DB\..\..\..\..\..\Components\stack\sec\ #
#                          " -I "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoo #
#                          m\Projects\zstack\Samples\GreenClassroom_NetWork   #
#                          2.1\CC2530DB\..\..\..\..\..\Components\stack\sys\" #
#                           -I "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom #
#                          \Projects\zstack\Samples\GreenClassroom_NetWork    #
#                          2.1\CC2530DB\..\..\..\..\..\Components\stack\zdo\" #
#                           -I "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom #
#                          \Projects\zstack\Samples\GreenClassroom_NetWork    #
#                          2.1\CC2530DB\..\..\..\..\..\Components\zmac\" -I   #
#                          "D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom\Pro #
#                          jects\zstack\Samples\GreenClassroom_NetWork        #
#                          2.1\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"  #
#                          -Ohz --require_prototypes                          #
#    List file          =  D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom\Proj #
#                          ects\zstack\Samples\GreenClassroom_NetWork         #
#                          2.1\CC2530DB\EndDeviceEB\List\hal_key.lst          #
#    Object file        =  D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom\Proj #
#                          ects\zstack\Samples\GreenClassroom_NetWork         #
#                          2.1\CC2530DB\EndDeviceEB\Obj\hal_key.r51           #
#                                                                             #
#                                                                             #
###############################################################################

D:\FileInstall\ZStack-CC2530-2.5.1a_GreenRoom\Projects\zstack\Samples\GreenClassroom_NetWork 2.1\Source\hal_key.c
      1          #include "hal_key.h"
      2          #include "my_hal_key_config.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf5
   \   unsigned char volatile __sfr P2SEL
   \                     P2SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1

   \                                 In  segment XDATA_ROM_C, align 1
   \   struct <unnamed> const __xdata_rom keyConfig[2]
   \                     keyConfig:
   \   000000   00           DB 0
   \   000001   02           DB 2
   \   000002   01           DB 1
   \   000003   00           DB 0
   \   000004   02           DB 2
   \   000005   01           DB 1
   \   000006   02           DB 2
   \   000007   00           DB 0
      3          #include "hal_adc.h"
      4          #include "OnBoard.h"
      5          #include "hal_drivers.h"
      6          
      7          //#define NO_TASK_ID 0xFF
      8          
      9          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
     10          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     11          bool Hal_KeyIntEnable = KEY_INPUT_INT_MODE;   
   \                     Hal_KeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     12          static bool HalKeyConfigured = FALSE;  // 按键是否初始化完成
   \                     HalKeyConfigured:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     13          
     14          /**************************************************************************************************
     15           *                                       私有函数
     16           **************************************************************************************************/
     17          uint8 halSendKeys_Msg( uint8 keys, uint8 state );
     18          void myHalKeyConfig (void);
     19          bool isNewKey( uint8 keys );
     20          
     21          #if ( defined KEY_NUM) && (KEY_NUM > 0 )
     22            static uint8 halGetNomalKeyInput(uint8 port, uint8 pin);
     23          #endif
     24            
     25          #if ( JOY_KEY_CONFIGURED == TRUE )
     26            static uint8 halGetJoyKeyInput(uint8 adChannel);
     27          #endif
     28          #if ( KEY_INPUT_INT_MODE == TRUE ) 
     29            bool isKeyInt( uint8 port );
     30          #endif
     31          
     32          /**************************************************************************************************
     33           * @fn      HalKeyInit
     34           *
     35           * @brief   按键初始化。
     36           *          这是按键初始化第一阶段，其调用链为：main()->HalDriverInit()->HalKeyInit()，即在驱动初始化时
     37           *          被调用。
     38           *          本函数执行后，按键可以工作在查询模式。用户可以通过调用HalKeyRead()获取按键状态，这样就可以满足
     39           *          某些任务在初始化时需要获取用户按键动作的需要。
     40           *          第二阶段的初始化工作由函数myHalKeyConfig()完成。
     41           *
     42           * @param   None
     43           *
     44           * @return  None
     45           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     46          void HalKeyInit( void )
   \                     HalKeyInit:
     47          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
     48            uint8 i;
     49          /****  如果定义了KEY_NUM, 则初始化普通按键  ****/ 
     50          #if (defined KEY_NUM) && (KEY_NUM > 0)
     51            
     52            for( i = 0; i < KEY_NUM; i++)
   \   000005   7900         MOV     R1,#0x0
     53            {
     54              switch (keyConfig[i].port)
   \                     ??HalKeyInit_0:
   \   000007   89..         MOV     ?V0 + 0,R1
   \   000009   75..00       MOV     ?V0 + 1,#0x0
   \   00000C   7402         MOV     A,#0x2
   \   00000E   78..         MOV     R0,#?V0 + 0
   \   000010   12....       LCALL   ?S_SHL
   \   000013   74..         MOV     A,#keyConfig & 0xff
   \   000015   25..         ADD     A,?V0 + 0
   \   000017   F582         MOV     DPL,A
   \   000019   74..         MOV     A,#(keyConfig >> 8) & 0xff
   \   00001B   35..         ADDC    A,?V0 + 1
   \   00001D   F583         MOV     DPH,A
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6008         JZ      ??HalKeyInit_1
   \   000022   14           DEC     A
   \   000023   600E         JZ      ??HalKeyInit_2
   \   000025   14           DEC     A
   \   000026   6014         JZ      ??HalKeyInit_3
   \   000028   8019         SJMP    ??HalKeyInit_4
     55              {
     56              case MY_PORT0:
     57                P0SEL &= ~keyConfig[i].pin; 
   \                     ??HalKeyInit_1:
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F4           CPL     A
   \   00002D   52F3         ANL     0xf3,A
     58                P0DIR &= ~keyConfig[i].pin;
   \   00002F   52FD         ANL     0xfd,A
     59                break;
   \   000031   8010         SJMP    ??HalKeyInit_4
     60              case MY_PORT1:
     61                P1SEL &= ~keyConfig[i].pin; 
   \                     ??HalKeyInit_2:
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F4           CPL     A
   \   000036   52F4         ANL     0xf4,A
     62                P1DIR &= ~keyConfig[i].pin;     
   \   000038   52FE         ANL     0xfe,A
     63                break;
   \   00003A   8007         SJMP    ??HalKeyInit_4
     64              case MY_PORT2:
     65                P2SEL &= ~keyConfig[i].pin; 
   \                     ??HalKeyInit_3:
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F4           CPL     A
   \   00003F   52F5         ANL     0xf5,A
     66                P2DIR &= ~keyConfig[i].pin;  
   \   000041   52FF         ANL     0xff,A
     67                break;
     68              }    
     69            }
   \                     ??HalKeyInit_4:
   \   000043   09           INC     R1
   \   000044   E9           MOV     A,R1
   \   000045   C3           CLR     C
   \   000046   9402         SUBB    A,#0x2
   \   000048   40BD         JC      ??HalKeyInit_0
     70          #endif  
     71            
     72          /* 如果定义了JOY_KEY_CONFIGURED，则初始化 joy stick。joy stick 采用AD输入 */ 
     73          #if (JOY_KEY_CONFIGURED == TRUE)
     74            
     75                P0SEL |= BV(JOY_AD_CHANNEL);   // 设置为外设引脚，AD输入通道在P0
     76                P0INP |= BV(JOY_AD_CHANNEL);   // 设置为三态模式，即没有上/下拉电阻  
     77                
     78          #endif
     79          
     80          }
   \   00004A                REQUIRE ?Subroutine0
   \   00004A                REQUIRE P0SEL
   \   00004A                REQUIRE P0DIR
   \   00004A                REQUIRE P1SEL
   \   00004A                REQUIRE P1DIR
   \   00004A                REQUIRE P2SEL
   \   00004A                REQUIRE P2DIR
   \   00004A                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
     81          
     82          /**************************************************************************************************
     83           * @fn      HalKeyConfig
     84           *
     85           * @brief   按键配置。
     86           *          此函数一是为了与原样板工程保持兼容，二是将真正的按键配置工作，也就是第二阶段初始化工作推迟
     87           *          3s。其调用链为：main()->InitBoard( OB_READY )->HalKeyConfig()。
     88           *          在ZStack原系统中，此函数是为了完成key的第二阶段初始化，即：如果按键采用中断输入模式，则初始化
     89           *          中断控制器，否则，启动按键的周期性查询工作。
     90           *          我们的驱动对此函数进行了改造：将第二阶段的初始化工作推迟3s进行，以避免系统误将系统初始化时的按
     91           *          按键动作传给用户任务处理。
     92           *          第二阶段的初始化工作由函数myHalKeyConfig()完成。
     93           *
     94           * @param   None
     95           *
     96           * @return  None
     97           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     98          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
   \                     HalKeyConfig:
     99          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    100            (void)(cback);            // 在我们的配置代码中，不使用这两个参数，
    101            (void)(interruptEnable);  // 保留这两个参数只是为了与原系统兼容。本驱动不再采用原系统的按键回调机制
    102            osal_start_timerEx( Hal_TaskID, HAL_KEY_EVENT,3000);  //推迟3s触发hal任务的HAL_KEY_EVENT事件
   \   000004                ; Setup parameters for call to function osal_start_timerEx
   \   000004   7CB8         MOV     R4,#-0x48
   \   000006   7D0B         MOV     R5,#0xb
   \   000008   7A01         MOV     R2,#0x1
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   90....       MOV     DPTR,#Hal_TaskID
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   12....       LCALL   ??osal_start_timerEx?relay
    103            return ;
   \   000014                REQUIRE ?Subroutine1
   \   000014                ; // Fall through to label ?Subroutine1
    104          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    105          
    106          /**************************************************************************************************
    107           * @fn      myHalKeyConfig
    108           *
    109           * @brief   按键配置，即进行按键的第二阶段初始化。
    110           *          如果按键采用中断输入模式，则初始化其中断控制器，否则，启动按键的周期性查询工作。
    111           *          此函数是按键驱动初始化的第二阶段。其调用链为：
    112           *                HAL_KEY_EVENT事件发生->Hal_ProcessEvent()->HalKeyPoll()->myHalKeyConfig()
    113           *          按键的第一阶段初始化由HalKeyInit()完成。
    114           *   
    115           * @param   None
    116           *
    117           * @return  keys - current keys status
    118           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    119          void myHalKeyConfig (void)
   \                     myHalKeyConfig:
    120          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    121          
    122          #if ( KEY_INPUT_INT_MODE == TRUE )
    123            /**** 如果采用中断输入模式，则需要初始化其中断控制器 *****/
    124            uint8 i;
    125            uint8 temp;
    126            for( i = 0; i < KEY_NUM; i++ )
    127            {//扫描用户的按键配置数组
    128              switch (keyConfig[i].port)
    129              {
    130              case MY_PORT0:
    131                temp = PICTL;
    132                PICTL = ( temp & ~BV(0) ) | ( EDGE_TRIGGER_MODE << 0 );  // 设置边沿触发方式：上升沿或下降沿  
    133                P0IFG &= ( ~keyConfig[i].pin ); // 清除残留的中断标志
    134                P0IEN |= keyConfig[i].pin; // 开放相应引脚中断
    135                IEN1 |= BV(5); // 开放P0中断
    136                break;
    137              case MY_PORT1:
    138                if( keyConfig[i].pin < 0x10 )
    139                {// P1 bit0-bit3 中断触发方式
    140                  temp = PICTL;
    141                  PICTL = ( temp & ~BV(1) ) | ( EDGE_TRIGGER_MODE << 1);  // 设置边沿触发方式：上升沿或下降沿        
    142                }
    143                else
    144                {// P1 bit4-bit7 中断触发方式
    145                  temp = PICTL;
    146                  PICTL = ( temp & ~BV(2) ) | ( EDGE_TRIGGER_MODE << 2);  // 设置边沿触发方式：上升沿或下降沿        
    147                }
    148                
    149                P1IFG &= ( ~keyConfig[i].pin ); // 清除残留的中断标志
    150                P1IEN |= keyConfig[i].pin; // 开放相应引脚中断  
    151                IEN2 |= BV(4); // 开放P1中断   
    152                break;
    153              case MY_PORT2:
    154                  temp = PICTL;
    155                  PICTL = ( temp & ~BV(3) ) | ( EDGE_TRIGGER_MODE << 3);  // 设置边沿触发方式：上升沿或下降沿      
    156                  P2IFG &= ( ~keyConfig[i].pin ); // 清除残留的中断标志
    157                  P2IEN |= keyConfig[i].pin; // 开放相应引脚中断        
    158                  IEN2 = BV(1); // 开放P2中断           
    159                break;
    160              }   
    161            }
    162          #endif
    163            HalKeyConfigured = TRUE;  // 按键两个阶段的初始化均已完成
   \   000004   90....       MOV     DPTR,#HalKeyConfigured
   \   000007   7401         MOV     A,#0x1
   \   000009   F0           MOVX    @DPTR,A
    164            return ;
   \   00000A   80..         SJMP    ?Subroutine1
    165          }
    166          
    167          
    168          
    169          
    170          /**************************************************************************************************
    171           * @fn      HalKeyRead
    172           *
    173           * @brief   读取当前按键状态。
    174           *          不管是按键工作在查询输入模式还是中断输入模式，应用程序都可以调用此函数读取当前按键状态。
    175           *          部分任务在初始化时就是调用该函数获知用户的按键操作从而决定如何初始化自己，如ZDApp任务。
    176           *
    177           * @param   None
    178           *
    179           * @return  keys - 当前按键状态
    180           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    181          uint8 HalKeyRead ( void )
   \                     HalKeyRead:
    182          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    183            uint8 keys = 0; //已按键集合
   \   000005   7900         MOV     R1,#0x0
    184            uint8 keyState; //按键当前状态
    185            uint8 i;
    186          
    187          /****  如果定义了KEY_NUM, 则获取普通按键ID  ****/   
    188          #if (defined KEY_NUM) && (KEY_NUM > 0)
    189            
    190            for( i = 0; i < KEY_NUM; i++)
   \   000007   7C00         MOV     R4,#0x0
    191            {
    192              keyState = halGetNomalKeyInput( keyConfig[i].port, keyConfig[i].pin );  // 读取普通按键状态
   \                     ??HalKeyRead_0:
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   75..00       MOV     ?V0 + 1,#0x0
   \   00000E   7402         MOV     A,#0x2
   \   000010   78..         MOV     R0,#?V0 + 0
   \   000012   12....       LCALL   ?S_SHL
   \   000015   74..         MOV     A,#keyConfig & 0xff
   \   000017   25..         ADD     A,?V0 + 0
   \   000019   FA           MOV     R2,A
   \   00001A   74..         MOV     A,#(keyConfig >> 8) & 0xff
   \   00001C   35..         ADDC    A,?V0 + 1
   \   00001E   FB           MOV     R3,A
   \   00001F   8A82         MOV     DPL,R2
   \   000021   8B83         MOV     DPH,R3
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F8           MOV     R0,A
   \   000026   7D00         MOV     R5,#0x0
   \   000028   8A82         MOV     DPL,R2
   \   00002A   8B83         MOV     DPH,R3
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   600E         JZ      ??HalKeyRead_1
   \   00002F   14           DEC     A
   \   000030   6007         JZ      ??HalKeyRead_2
   \   000032   14           DEC     A
   \   000033   700C         JNZ     ??HalKeyRead_3
   \   000035   E5A0         MOV     A,0xa0
   \   000037   8006         SJMP    ??HalKeyRead_4
   \                     ??HalKeyRead_2:
   \   000039   E590         MOV     A,0x90
   \   00003B   8002         SJMP    ??HalKeyRead_4
   \                     ??HalKeyRead_1:
   \   00003D   E580         MOV     A,0x80
   \                     ??HalKeyRead_4:
   \   00003F   58           ANL     A,R0
   \   000040   FD           MOV     R5,A
    193          
    194              if( !( keyState ^ keyConfig[i].polarity ) ) // 按键状态与极性异或后取反，其结果为真，则键按下，否则没有按下。
   \                     ??HalKeyRead_3:
   \   000041   8C..         MOV     ?V0 + 0,R4
   \   000043   75..00       MOV     ?V0 + 1,#0x0
   \   000046   7402         MOV     A,#0x2
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?S_SHL
   \   00004D   74..         MOV     A,#(keyConfig + 3) & 0xff
   \   00004F   25..         ADD     A,?V0 + 0
   \   000051   F582         MOV     DPL,A
   \   000053   74..         MOV     A,#((keyConfig + 3) >> 8) & 0xff
   \   000055   35..         ADDC    A,?V0 + 1
   \   000057   F583         MOV     DPH,A
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   6D           XRL     A,R5
   \   00005B   701C         JNZ     ??HalKeyRead_5
    195              {
    196                keys |= keyConfig[i].keyID; // 将按键状态转换为按键编码 
   \   00005D   8C..         MOV     ?V0 + 0,R4
   \   00005F   75..00       MOV     ?V0 + 1,#0x0
   \   000062   7402         MOV     A,#0x2
   \   000064   78..         MOV     R0,#?V0 + 0
   \   000066   12....       LCALL   ?S_SHL
   \   000069   74..         MOV     A,#(keyConfig + 2) & 0xff
   \   00006B   25..         ADD     A,?V0 + 0
   \   00006D   F582         MOV     DPL,A
   \   00006F   74..         MOV     A,#((keyConfig + 2) >> 8) & 0xff
   \   000071   35..         ADDC    A,?V0 + 1
   \   000073   F583         MOV     DPH,A
   \   000075   E0           MOVX    A,@DPTR
   \   000076   C9           XCH     A,R1
   \   000077   49           ORL     A,R1
   \   000078   F9           MOV     R1,A
    197              }
    198            }
   \                     ??HalKeyRead_5:
   \   000079   0C           INC     R4
   \   00007A   EC           MOV     A,R4
   \   00007B   C3           CLR     C
   \   00007C   9402         SUBB    A,#0x2
   \   00007E   4089         JC      ??HalKeyRead_0
    199            
    200          #endif
    201            
    202          /* 如果定义了JOY_KEY_CONFIGURED，则获取joy stick ID */ 
    203          #if (JOY_KEY_CONFIGURED == TRUE)
    204            
    205            keys |= halGetJoyKeyInput(JOY_AD_CHANNEL);
    206            
    207          #endif 
    208          
    209            return keys;
   \   000080   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000083                REQUIRE _A_P0
   \   000083                REQUIRE _A_P1
   \   000083                REQUIRE _A_P2
    210          }
    211          
    212          
    213          /**************************************************************************************************
    214           * @fn      HalKeyPoll
    215           *
    216           * @brief   查询按键状态，如果有按键动作，则将按键包装成消息发送给上层用户任务进行处理。另外，本函数
    217           *          还承担按键的第二阶段初始化工作，即如果使用中断输入模式，则调用myHalKeyConfig()初始化中断
    218           *          控制器。
    219           *
    220           * @param   None
    221           *
    222           * @return  None
    223           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    224          void HalKeyPoll (void)
   \                     HalKeyPoll:
    225          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    226            uint8 keys = 0;   //当前按键
    227            bool shiftKeyState = FALSE ; // 记录shift key状态，TRUE:按下，FALSE: 未按下
    228            
    229            if( !HalKeyConfigured ) //如果还没有初始化完
   \   000005   90....       MOV     DPTR,#HalKeyConfigured
   \   000008   E0           MOVX    A,@DPTR
   \   000009   7005         JNZ     ??HalKeyPoll_0
    230            {
    231              myHalKeyConfig(); // 进行按键的第二阶段初始化
   \   00000B   7401         MOV     A,#0x1
   \   00000D   F0           MOVX    @DPTR,A
    232              return;
   \   00000E   8012         SJMP    ??HalKeyPoll_1
    233            }
    234            keys = HalKeyRead(); // 读取按键状态
   \                     ??HalKeyPoll_0:
   \   000010                ; Setup parameters for call to function HalKeyRead
   \   000010   12....       LCALL   ??HalKeyRead?relay
   \   000013   E9           MOV     A,R1
   \   000014   FE           MOV     R6,A
    235          
    236          /*** 如果配置了 shift key， 则检测 shift key是否按下 ***/
    237            
    238            
    239          #if ( KEY_INPUT_INT_MODE == TRUE )
    240            if( keys )  //如果采用中断输入模式，则直接将按键封装成消息发送
    241          #else    
    242           if( isNewKey(keys) )   //如果采用查询工作查式，进一步判断是否为新的按键
   \   000015                ; Setup parameters for call to function isNewKey
   \   000015   12....       LCALL   ??isNewKey?relay
   \   000018   E9           MOV     A,R1
   \   000019   6007         JZ      ??HalKeyPoll_1
    243          #endif
    244           { // 如果是新的按键则发送给App
    245          #if (SHIF_KEY_CONFIGURED == TRUE)
    246            
    247            shiftKeyState = ( keys & MY_SHIFT_KEY_ID ) ? TRUE:FALSE;   // 判断shift key状态，TRUE:按下，FALSE: 未按下
    248            keys = keys & (~MY_SHIFT_KEY_ID);         // 清除按键表中的shift key对应的位
    249            
    250          #endif   
    251             OnBoard_SendKeys( keys, shiftKeyState );  //向应用App发送按键消息
   \   00001B                ; Setup parameters for call to function OnBoard_SendKeys
   \   00001B   7A00         MOV     R2,#0x0
   \   00001D   EE           MOV     A,R6
   \   00001E   F9           MOV     R1,A
   \   00001F   12....       LCALL   ??OnBoard_SendKeys?relay
   \                     ??HalKeyPoll_1:
   \   000022   7F01         MOV     R7,#0x1
   \   000024   02....       LJMP    ?BANKED_LEAVE_XDATA
    252           }
    253           
    254            return ;
    255          }
    256          
    257          
    258          /**************************************************************************************************
    259           * @fn      isNewKey
    260           *
    261           * @brief  本函数判断是否为新的按键。
    262           *        当用户按住一个键的时间<0.8s，则认为是一次按键，超过0.8s，则认为是需要自动重复按键
    263           * @param   keys，当前按键状态
    264           *
    265           * @return  TRUE or FALSE
    266           **************************************************************************************************/
    267          #if ( KEY_INPUT_INT_MODE == FALSE ) 

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    268          bool isNewKey( uint8 keys )
   \                     isNewKey:
    269          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
    270            static uint8 sameKeyCount = 0;   // 相同按键计数
    271            static uint8 preKey = 0;  // 上一次按键  
    272            if( keys == 0 )
   \   000006   90....       MOV     DPTR,#??preKey
   \   000009   7009         JNZ     ??isNewKey_0
    273            { // 没有按按键动作
    274              preKey = 0;
   \   00000B   E4           CLR     A
   \   00000C   F0           MOVX    @DPTR,A
    275              sameKeyCount = 0;
   \   00000D   90....       MOV     DPTR,#??sameKeyCount
   \   000010   F0           MOVX    @DPTR,A
    276              return FALSE; 
   \   000011   F9           MOV     R1,A
   \   000012   801F         SJMP    ??isNewKey_1
    277            }
    278            if( keys != preKey )
   \                     ??isNewKey_0:
   \   000014   E0           MOVX    A,@DPTR
   \   000015   68           XRL     A,R0
   \   000016   6009         JZ      ??isNewKey_2
    279            { // 如果有按键动作，且与前一次按下的键不相同，则判定为新的按键
    280              preKey = keys;
   \   000018   E8           MOV     A,R0
   \   000019   F0           MOVX    @DPTR,A
    281              sameKeyCount = 0;
   \   00001A   90....       MOV     DPTR,#??sameKeyCount
   \   00001D   E4           CLR     A
   \   00001E   F0           MOVX    @DPTR,A
    282              return TRUE;
   \   00001F   8010         SJMP    ??isNewKey_3
    283            }
    284            if( (keys == preKey) && (sameKeyCount < KEY_REPETITION_INTERVAL) )
   \                     ??isNewKey_2:
   \   000021   90....       MOV     DPTR,#??sameKeyCount
   \   000024   E0           MOVX    A,@DPTR
   \   000025   C3           CLR     C
   \   000026   9405         SUBB    A,#0x5
   \   000028   5007         JNC     ??isNewKey_3
    285            { // 如果当前按键与前一次相同，且间隔时间 < KEY_REPETITION_INTERVAL*100 mS,则认为是同一次按键，不发送给App
    286              sameKeyCount++;
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   04           INC     A
   \   00002C   F0           MOVX    @DPTR,A
    287              return FALSE;
   \   00002D   7900         MOV     R1,#0x0
   \   00002F   8002         SJMP    ??isNewKey_1
    288            }
    289            if((keys == preKey) && (sameKeyCount >= KEY_REPETITION_INTERVAL) )
    290            {// 如果当前按键与前一次相同，且间隔时间 > KEY_REPETITION_INTERVAL*100mS, 则认为用户是要自动重复按键，发送给App
    291              return TRUE;    
   \                     ??isNewKey_3:
   \   000031   7901         MOV     R1,#0x1
    292            }
   \                     ??isNewKey_1:
   \   000033   02....       LJMP    ?Subroutine1 & 0xFFFF
    293            return FALSE;
    294          }

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??sameKeyCount:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??preKey:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??myHalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    myHalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??isNewKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    isNewKey
    295          #endif
    296          
    297          /**************************************************************************************************
    298           * @fn      halGetNomalKeyInput
    299           *
    300           * @brief  读取普通按键输入状态。普通按键是指以高低电平为输入的按键。非普通按键是指以模拟信号为输入的按键
    301           *        当用户按住一个键的时间<0.8s，则认为是一次按键，超过0.8s，则认为是需要自动重复按键
    302           * @param   port：按键所连接的端口
    303          *           pin: 按键所连接的引脚
    304           *
    305           * @return  keyState： 按键状态，即哪个引脚有按键动作
    306           **************************************************************************************************/ 
    307          #if (defined KEY_NUM) && (KEY_NUM > 0)
    308          uint8 halGetNomalKeyInput(uint8 port, uint8 pin)
    309          {
    310              uint8 keyState = 0;
    311              switch (port)
    312              {
    313              case MY_PORT0:
    314                keyState =  ( P0 & pin ); // 读取P0口按键状态      
    315                break;
    316              case MY_PORT1:
    317                keyState =  ( P1 & pin ); // 读取P1口按键状态          
    318                break;
    319              case MY_PORT2:
    320                keyState =  ( P2 & pin ); // 读取P2口按键状态       
    321                break;    
    322              }  
    323            return keyState;
    324          }
    325          #endif
    326          
    327          
    328          
    329          /**************************************************************************************************
    330           * @fn      halGetJoyKeyInput
    331           *
    332           * @brief   读取joy stick 按键输入状态。joy stick采用模拟信号输入。
    333           *
    334           * @param   adChannel：joy stick所接入的模拟通道号
    335           *
    336           * @return  keyID - 用户按键所对应的编码
    337           **************************************************************************************************/
    338          #if (JOY_KEY_CONFIGURED == TRUE)
    339          uint8 halGetJoyKeyInput(uint8 adChannel)
    340          {
    341          
    342            uint8 keyID = 0;   
    343            uint8 adc;
    344          
    345            uint8 preKeyID; 
    346            uint8 i;
    347          
    348            /* 连续读取两次按键状态，如果两次均相同，则认为是有效按键动作 */
    349            do
    350            {
    351              preKeyID = keyID;    /* save previouse key reading */
    352          
    353              adc = HalAdcRead ( adChannel, HAL_ADC_RESOLUTION_8 );
    354          
    355              for( i = 0; i<5; i++ )
    356              {
    357                if( (adc >= joyStickADRange[i].lowerLimit) && (adc <= joyStickADRange[i].upperLimit) )
    358                {
    359                  keyID |= joyStickADRange[i].keyID;  // 将模拟输入值映射为按键ID
    360                }    
    361              }  
    362            } while (keyID != preKeyID);
    363          
    364            return keyID;
    365          }
    366          #endif
    367          
    368          
    369          #if ( P0_INT_ENABLE == TRUE )
    370          /**************************************************************************************************
    371           * @fn      halKeyPort0Isr
    372           *
    373           * @brief   Port0 ISR
    374           *
    375           * @param
    376           *
    377           * @return
    378           **************************************************************************************************/
    379          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
    380          {
    381          
    382            HAL_ENTER_ISR();
    383          
    384            if( isKeyInt( MY_PORT0) ) // 如果是P0的按键中断
    385            { 
    386              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, KEY_REPETITION_INTERVAL); //延迟读取按键，即消抖
    387            }
    388            
    389            CLEAR_SLEEP_MODE();
    390            HAL_EXIT_ISR();
    391          }  
    392          #endif
    393          
    394          #if ( P1_INT_ENABLE == TRUE )
    395          /**************************************************************************************************
    396           * @fn      halKeyPort1Isr
    397           *
    398           * @brief   Port1 ISR
    399           *
    400           * @param
    401           *
    402           * @return
    403           **************************************************************************************************/      
    404          HAL_ISR_FUNCTION( halKeyPort1Isr, P1INT_VECTOR )
    405          {
    406          
    407            HAL_ENTER_ISR();
    408          
    409            if( isKeyInt(MY_PORT1) ) // 如果是P1的按键中断
    410            { 
    411              osal_start_timerEx ( Hal_TaskID, HAL_KEY_EVENT, KEY_REPETITION_INTERVAL ); //延迟读取按键，即消抖
    412            }
    413            
    414            CLEAR_SLEEP_MODE();
    415            HAL_EXIT_ISR();
    416          }  
    417          #endif
    418          
    419          
    420          #if ( P2_INT_ENABLE == TRUE )
    421          /**************************************************************************************************
    422           * @fn      halKeyPort2Isr
    423           *
    424           * @brief   Port2 ISR
    425           *
    426           * @param
    427           *
    428           * @return
    429           **************************************************************************************************/      
    430          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
    431          {
    432          
    433            HAL_ENTER_ISR();
    434          
    435            if( isKeyInt(MY_PORT2) ) // 如果是P2的按键中断
    436            { 
    437              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, KEY_REPETITION_INTERVAL); //延迟读取按键，即消抖
    438            }
    439            
    440            CLEAR_SLEEP_MODE();
    441            HAL_EXIT_ISR();
    442          }   
    443          #endif
    444            
    445          
    446          
    447          #if ( KEY_INPUT_INT_MODE == TRUE )
    448          
    449          /**************************************************************************************************
    450           * @fn      isKeyInt
    451           *
    452           * @brief   判断中断源是否为按键，如果是则同时清除相应标志位
    453           *
    454           * @param   None
    455           *
    456           * @return  isKeyInt - 如果按键产生的中断，则返回TRUE, 否则为FALSE 
    457           **************************************************************************************************/
    458          bool isKeyInt( uint8 port )
    459          {
    460            uint8 i;
    461            bool isKeyInt = FALSE;
    462           for( i = 0; i < KEY_NUM; i++ )
    463            {
    464              if( port == keyConfig[i].port )
    465              {
    466                switch (keyConfig[i].port)
    467                {
    468                case MY_PORT0:
    469                  isKeyInt |= ( P0IFG & keyConfig[i].pin ) ? TRUE: FALSE;
    470                  if( isKeyInt )
    471                  {
    472                    P0IFG &= ~keyConfig[i].pin; // 清除P0端口对应引脚的中断标志
    473                    P0IF = 0; // 清除P0的总中断标志
    474                  }
    475                  break;
    476                case MY_PORT1:
    477                  isKeyInt |= ( P1IFG & keyConfig[i].pin ) ? TRUE: FALSE;
    478                  if( isKeyInt )
    479                  {
    480                    P1IFG &= ~keyConfig[i].pin; // 清除P0端口对应引脚的中断标志
    481                    P1IF = 0; // 清除P0的总中断标志
    482                  }        
    483                  break;   
    484                case MY_PORT2:
    485                  isKeyInt |= ( P2IFG & keyConfig[i].pin ) ? TRUE: FALSE;
    486                  if( isKeyInt )
    487                  {
    488                    P2IFG &= ~keyConfig[i].pin; // 清除P0端口对应引脚的中断标志
    489                    P2IF = 0; // 清除P0的总中断标志
    490                  }         
    491                  break;
    492                }     
    493              }
    494            }
    495          
    496           return isKeyInt;
    497          
    498          }
    499          
    500          /**************************************************************************************************
    501           * @fn      HalKeyEnterSleep
    502           *
    503           * @brief  - Get called to enter sleep mode
    504           *
    505           * @param
    506           *
    507           * @return
    508           **************************************************************************************************/
    509          void HalKeyEnterSleep ( void )
    510          {
    511          }
    512          
    513          /**************************************************************************************************
    514           * @fn      HalKeyExitSleep
    515           *
    516           * @brief   - Get called when sleep is over
    517           *
    518           * @param
    519           *
    520           * @return  - return saved keys
    521           **************************************************************************************************/
    522          uint8 HalKeyExitSleep ( void )
    523          {
    524            /* Wake up and read keys */
    525            return ( HalKeyRead () );
    526          }
    527          
    528          #endif
    529          
    530          
    531          #else
    532          
    533          
    534          void HalKeyInit(void){}
    535          void HalKeyConfig(bool interruptEnable, halKeyCBack_t cback){}
    536          uint8 HalKeyRead(void){ return 0;}
    537          void HalKeyPoll(void){}
    538          
    539          #endif /* HAL_KEY */

   Maximum stack usage in bytes:

     Function                ISTACK PSTACK XSTACK
     --------                ------ ------ ------
     HalKeyConfig                2      0      0
       -> osal_start_timerEx     4      0      0
     HalKeyInit                  0      0     10
     HalKeyPoll                  0      0      9
       -> HalKeyRead             0      0     18
       -> isNewKey               0      0     18
       -> OnBoard_SendKeys       0      0     18
     HalKeyRead                  0      0     19
     isNewKey                    2      0      9
     myHalKeyConfig              2      0      0


   Segment part sizes:

     Function/Label         Bytes
     --------------         -----
     _A_P0                     1
     _A_P1                     1
     _A_P2                     1
     P0SEL                     1
     P1SEL                     1
     P2SEL                     1
     P0DIR                     1
     P1DIR                     1
     P2DIR                     1
     keyConfig                 8
     Hal_KeyIntEnable          1
     HalKeyConfigured          1
     HalKeyInit               74
     ?Subroutine0              5
     HalKeyConfig             20
     ?Subroutine1              7
     myHalKeyConfig           12
     HalKeyRead              131
     HalKeyPoll               39
     isNewKey                 54
     sameKeyCount              1
     preKey                    1
     ??HalKeyInit?relay        6
     ??HalKeyConfig?relay      6
     ??myHalKeyConfig?relay    6
     ??HalKeyRead?relay        6
     ??HalKeyPoll?relay        6
     ??isNewKey?relay          6

 
 342 bytes in segment BANKED_CODE
  36 bytes in segment BANK_RELAYS
   9 bytes in segment SFR_AN
   8 bytes in segment XDATA_ROM_C
   4 bytes in segment XDATA_Z
 
 378 bytes of CODE  memory
   8 bytes of CONST memory
   0 bytes of DATA  memory (+ 9 bytes shared)
   4 bytes of XDATA memory

Errors: none
Warnings: none
